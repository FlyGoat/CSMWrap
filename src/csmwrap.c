#include <efi.h>
#include <csmwrap.h>

#include <io.h>
#include <x86thunk.h>
#include <video.h>
#include <bootdev.h>
#include <iommu.h>
#include <apic.h>
#include <pci.h>
#include <bios_proxy.h>
#include <mptable.h>
#include <flanterm.h>
#include <flanterm_backends/fb.h>

// Generated by: xxd -i Csm16.bin >> Csm16.h
#include <bins/Csm16.h>


#ifndef BUILD_VERSION
#define BUILD_VERSION "Unknown"
#endif

const char *banner = "CSMWrap Version " BUILD_VERSION "\n"
                     "https://github.com/flygoat/csmwrap\n"
                     "By: Jiaxun Yang <jiaxun.yang@flygoat.com>\n";

EFI_SYSTEM_TABLE *gST;
EFI_BOOT_SERVICES *gBS;
EFI_RUNTIME_SERVICES *gRT;
EFI_TIME gTimeAtBoot;

struct csmwrap_priv priv = {
    .csm_bin = Csm16_bin,
};

/*
 * UEFI memory allocation wrappers for Flanterm.
 * These use EFI Boot Services pool allocation.
 */
static void *flanterm_uefi_malloc(size_t size)
{
    void *ptr = NULL;
    if (gBS->AllocatePool(EfiLoaderData, size, &ptr) != EFI_SUCCESS) {
        return NULL;
    }
    return ptr;
}

static void flanterm_uefi_free(void *ptr, size_t size)
{
    (void)size;  /* UEFI FreePool doesn't need size */
    if (ptr != NULL) {
        gBS->FreePool(ptr);
    }
}

static void *find_table(uint32_t signature, uint8_t *csm_bin_base, size_t size)
{
    bool Done;
    uint8_t *Ptr;
    void *Table;

    Done  = FALSE;
    Table = NULL;
    for (Ptr = csm_bin_base; Ptr < (csm_bin_base + size) && !Done; Ptr += 0x10) {
        if (*(uint32_t *)Ptr == signature) {
            Table  = Ptr;
            // FIXME: Get checksum?
            Done = TRUE;
        }
    }

    return Table;
}

/*
 * SMBIOS entry point structures
 */
#define SMBIOS_21_SIGNATURE 0x5f4d535f  /* "_SM_" */
#define SMBIOS_21_ENTRY_POINT_LENGTH 0x1F  /* Standard length */

#pragma pack(1)
struct smbios_21_entry_point {
    uint32_t signature;                    /* "_SM_" */
    uint8_t checksum;                      /* Checksum of bytes 0x00-0x0F */
    uint8_t length;                        /* Entry point length (usually 0x1F) */
    uint8_t smbios_major_version;
    uint8_t smbios_minor_version;
    uint16_t max_structure_size;
    uint8_t entry_point_revision;
    uint8_t formatted_area[5];
    char intermediate_anchor_string[5];    /* "_DMI_" */
    uint8_t intermediate_checksum;         /* Checksum of bytes 0x10-0x1E */
    uint16_t structure_table_length;       /* Total length of structure table */
    uint32_t structure_table_address;      /* Physical address of structure table */
    uint16_t number_of_structures;
    uint8_t smbios_bcd_revision;
};

struct smbios_30_entry_point {
    char signature[5];                     /* "_SM3_" */
    uint8_t checksum;
    uint8_t length;
    uint8_t smbios_major_version;
    uint8_t smbios_minor_version;
    uint8_t smbios_docrev;
    uint8_t entry_point_revision;
    uint8_t reserved;
    uint32_t structure_table_max_size;
    uint64_t structure_table_address;      /* 64-bit! */
};

/* SMBIOS structure header - at the start of every structure */
struct smbios_structure_header {
    uint8_t type;
    uint8_t length;    /* Length of formatted area only, not including strings */
    uint16_t handle;
};
#pragma pack()

static uint8_t smbios_checksum(const void *data, size_t len)
{
    const uint8_t *p = data;
    uint8_t sum = 0;
    for (size_t i = 0; i < len; i++)
        sum += p[i];
    return sum;
}

/*
 * Statistics gathered from walking the SMBIOS structure table.
 * Using uint32_t for sizes to avoid overflow during calculation,
 * even though SMBIOS 2.x limits these to 16-bit values.
 */
struct smbios_table_stats {
    uint32_t number_of_structures;
    uint32_t max_structure_size;
    uint32_t table_length;
};

/*
 * Walk the SMBIOS structure table and gather statistics.
 * The structure table format is the same for SMBIOS 2.x and 3.0.
 *
 * Each structure consists of:
 * - Formatted area (header.length bytes, starting with the header)
 * - Unformatted area (null-terminated strings, ending with double-null)
 *
 * Returns true on success, false if the table appears corrupted.
 */
static bool smbios_walk_table(const void *table, uint32_t max_size, struct smbios_table_stats *stats)
{
    const uint8_t *ptr = table;
    const uint8_t *end = ptr + max_size;

    stats->number_of_structures = 0;
    stats->max_structure_size = 0;
    stats->table_length = 0;

    while (ptr + sizeof(struct smbios_structure_header) <= end) {
        const struct smbios_structure_header *hdr = (const struct smbios_structure_header *)ptr;

        /* Sanity check: length must be at least header size */
        if (hdr->length < sizeof(struct smbios_structure_header)) {
            printf("  Warning: Invalid structure length %u at offset %u\n",
                   hdr->length, (uint32_t)(ptr - (const uint8_t *)table));
            return false;
        }

        /* Check formatted area doesn't exceed bounds */
        if (ptr + hdr->length > end) {
            printf("  Warning: Structure exceeds table bounds\n");
            return false;
        }

        /* Find the end of the unformatted area (strings) */
        const uint8_t *strings_start = ptr + hdr->length;
        const uint8_t *strings_ptr = strings_start;

        /* Look for double-null terminator */
        while (strings_ptr + 1 < end) {
            if (strings_ptr[0] == 0 && strings_ptr[1] == 0) {
                strings_ptr += 2;  /* Include both nulls */
                break;
            }
            strings_ptr++;
        }

        if (strings_ptr + 1 >= end && !(strings_ptr[-2] == 0 && strings_ptr[-1] == 0)) {
            /* Didn't find double-null before end - table might be truncated */
            printf("  Warning: Missing double-null terminator\n");
            return false;
        }

        /* Calculate this structure's total size */
        uint32_t struct_size = (uint32_t)(strings_ptr - ptr);
        if (struct_size > stats->max_structure_size) {
            stats->max_structure_size = struct_size;
        }

        stats->number_of_structures++;

        /* Type 127 marks end of table */
        if (hdr->type == 127) {
            stats->table_length = (uint32_t)(strings_ptr - (const uint8_t *)table);
            return true;
        }

        ptr = strings_ptr;
    }

    /* Reached end without finding type 127 - use what we have */
    stats->table_length = (uint32_t)(ptr - (const uint8_t *)table);
    return true;
}

/*
 * Allocated buffer for synthesized/relocated SMBIOS data.
 */
static void *smbios_buffer = NULL;

/*
 * Synthesize an SMBIOS 2.x entry point from SMBIOS 3.0 data.
 * The structure table data format is identical; only the entry point differs.
 *
 * Allocates memory for entry point + structure table below 4GB.
 * Returns the new SMBIOS 2.x entry point, or NULL on failure.
 */
static struct smbios_21_entry_point *synthesize_smbios_21_from_30(
    struct smbios_30_entry_point *ep30,
    uint64_t st_addr,
    uint32_t st_max_size)
{
    /* Walk the structure table to get accurate statistics */
    struct smbios_table_stats stats;
    if (!smbios_walk_table((void *)(uintptr_t)st_addr, st_max_size, &stats)) {
        printf("  Failed to parse SMBIOS structure table\n");
        return NULL;
    }

    printf("  Table stats: %u structures, max size %u, actual length %u\n",
           stats.number_of_structures, stats.max_structure_size, stats.table_length);

    /* Check for SMBIOS 2.x limitations (16-bit fields) */
    if (stats.table_length > 0xFFFF) {
        printf("  Warning: Table length %u exceeds SMBIOS 2.x limit (65535)\n",
               stats.table_length);
        /* Truncate - some data will be missing but better than nothing */
        stats.table_length = 0xFFFF;
    }
    if (stats.max_structure_size > 0xFFFF) {
        printf("  Warning: Max structure size exceeds SMBIOS 2.x limit\n");
        stats.max_structure_size = 0xFFFF;
    }
    if (stats.number_of_structures > 0xFFFF) {
        printf("  Warning: Structure count exceeds SMBIOS 2.x limit\n");
        stats.number_of_structures = 0xFFFF;
    }

    /* Allocate buffer for entry point + structure table below 4GB */
    size_t total_size = SMBIOS_21_ENTRY_POINT_LENGTH + stats.table_length;
    EFI_PHYSICAL_ADDRESS max_addr = 0xFFFFFFFF;
    EFI_STATUS status = gBS->AllocatePages(
        AllocateMaxAddress,
        EfiRuntimeServicesData,
        (total_size + EFI_PAGE_SIZE - 1) / EFI_PAGE_SIZE,
        &max_addr
    );

    if (status != EFI_SUCCESS) {
        printf("  Failed to allocate memory for SMBIOS synthesis\n");
        return NULL;
    }

    smbios_buffer = (void *)(uintptr_t)max_addr;
    printf("  Synthesizing SMBIOS 2.x at %p\n", smbios_buffer);

    /* Build the SMBIOS 2.x entry point */
    struct smbios_21_entry_point *ep21 = smbios_buffer;
    memset(ep21, 0, SMBIOS_21_ENTRY_POINT_LENGTH);

    ep21->signature = SMBIOS_21_SIGNATURE;
    ep21->length = SMBIOS_21_ENTRY_POINT_LENGTH;
    ep21->smbios_major_version = ep30->smbios_major_version;
    ep21->smbios_minor_version = ep30->smbios_minor_version;
    ep21->max_structure_size = (uint16_t)stats.max_structure_size;
    ep21->entry_point_revision = 0;
    memcpy(ep21->intermediate_anchor_string, "_DMI_", 5);
    ep21->structure_table_length = (uint16_t)stats.table_length;
    ep21->number_of_structures = stats.number_of_structures;

    /* BCD revision: major in high nibble, minor in low nibble */
    ep21->smbios_bcd_revision = ((ep30->smbios_major_version & 0xF) << 4) |
                                 (ep30->smbios_minor_version & 0xF);

    /* Copy structure table after entry point */
    void *st_dest = (uint8_t *)smbios_buffer + SMBIOS_21_ENTRY_POINT_LENGTH;
    memcpy(st_dest, (void *)(uintptr_t)st_addr, stats.table_length);
    ep21->structure_table_address = (uint32_t)(uintptr_t)st_dest;

    /* Calculate checksums */
    ep21->checksum = 0;
    ep21->intermediate_checksum = 0;
    ep21->intermediate_checksum = -smbios_checksum((uint8_t *)ep21 + 0x10,
                                                    SMBIOS_21_ENTRY_POINT_LENGTH - 0x10);
    ep21->checksum = -smbios_checksum(ep21, 0x10);

    printf("  Synthesis complete: SMBIOS %u.%u, %u structures, table at %x\n",
           ep21->smbios_major_version, ep21->smbios_minor_version,
           ep21->number_of_structures, ep21->structure_table_address);

    return ep21;
}

#ifdef __x86_64__
/*
 * Relocate SMBIOS 2.x entry point and structure table to below 4GB.
 * Only needed on 64-bit systems where SMBIOS data may be above 4GB.
 * Returns the new entry point address, or NULL on failure.
 */
static struct smbios_21_entry_point *relocate_smbios_21(
    struct smbios_21_entry_point *ep,
    uint64_t st_addr,
    uint32_t st_size)
{
    size_t ep_size = ep->length;
    size_t total_size = ep_size + st_size;

    /* Allocate below 4GB */
    EFI_PHYSICAL_ADDRESS max_addr = 0xFFFFFFFF;
    EFI_STATUS status = gBS->AllocatePages(
        AllocateMaxAddress,
        EfiRuntimeServicesData,
        (total_size + EFI_PAGE_SIZE - 1) / EFI_PAGE_SIZE,
        &max_addr
    );

    if (status != EFI_SUCCESS) {
        printf("  Failed to allocate memory for SMBIOS relocation\n");
        return NULL;
    }

    smbios_buffer = (void *)(uintptr_t)max_addr;
    printf("  Relocating SMBIOS to %p\n", smbios_buffer);

    /* Copy entry point */
    struct smbios_21_entry_point *new_ep = smbios_buffer;
    memcpy(new_ep, ep, ep_size);

    /* Copy structure table right after entry point */
    void *new_st = (uint8_t *)smbios_buffer + ep_size;
    memcpy(new_st, (void *)(uintptr_t)st_addr, st_size);

    /* Update structure table address in the new entry point */
    new_ep->structure_table_address = (uint32_t)(uintptr_t)new_st;

    /* Recalculate checksums */
    new_ep->checksum = 0;
    new_ep->intermediate_checksum = 0;
    new_ep->intermediate_checksum = -smbios_checksum((uint8_t *)new_ep + 0x10, ep_size - 0x10);
    new_ep->checksum = -smbios_checksum(new_ep, 0x10);

    printf("  Relocation complete, new structure table at %x\n",
           new_ep->structure_table_address);

    return new_ep;
}
#endif /* __x86_64__ */

int set_smbios_table()
{
    EFI_GUID smbiosGuid = SMBIOS_TABLE_GUID;
    EFI_GUID smbios3Guid = SMBIOS3_TABLE_GUID;
    struct smbios_21_entry_point *result_ep = NULL;

    /* First, try to find SMBIOS 2.x table (preferred for legacy compatibility) */
    for (size_t i = 0; i < gST->NumberOfTableEntries; i++) {
        EFI_CONFIGURATION_TABLE *table = gST->ConfigurationTable + i;

        if (!efi_guidcmp(table->VendorGuid, smbiosGuid)) {
            struct smbios_21_entry_point *ep = table->VendorTable;
            printf("Found SMBIOS 2.x entry point at %p\n", (void *)ep);

            /* Validate signature */
            if (ep->signature != SMBIOS_21_SIGNATURE) {
                printf("  Invalid signature, skipping\n");
                continue;
            }

            /* Validate checksums */
            if (smbios_checksum(ep, 0x10) != 0) {
                printf("  Invalid entry point checksum, skipping\n");
                continue;
            }
            if (memcmp(ep->intermediate_anchor_string, "_DMI_", 5) != 0) {
                printf("  Invalid DMI anchor, skipping\n");
                continue;
            }
            if (smbios_checksum((uint8_t *)ep + 0x10, ep->length - 0x10) != 0) {
                printf("  Invalid intermediate checksum, skipping\n");
                continue;
            }

            printf("  Version: %u.%u, structure table at %x, length %u\n",
                   ep->smbios_major_version, ep->smbios_minor_version,
                   ep->structure_table_address, ep->structure_table_length);

#ifdef __x86_64__
            /* Check if entry point or structure table is above 4GB */
            uint64_t ep_addr = (uint64_t)(uintptr_t)ep;
            uint64_t st_addr = ep->structure_table_address;

            if (ep_addr >= 0x100000000ULL || st_addr >= 0x100000000ULL) {
                printf("  Entry point or structure table above 4GB, relocation needed\n");
                result_ep = relocate_smbios_21(ep, st_addr, ep->structure_table_length);
                break;
            }
#endif
            result_ep = ep;
            break;
        }
    }

    /*
     * If SMBIOS 2.x not found/usable, try SMBIOS 3.0.
     * We synthesize an SMBIOS 2.x entry point from the 3.0 data since
     * SeaBIOS and legacy operating systems only understand 2.x format.
     */
    if (!result_ep) {
        for (size_t i = 0; i < gST->NumberOfTableEntries; i++) {
            EFI_CONFIGURATION_TABLE *table = gST->ConfigurationTable + i;

            if (!efi_guidcmp(table->VendorGuid, smbios3Guid)) {
                struct smbios_30_entry_point *ep = table->VendorTable;
                printf("Found SMBIOS 3.0 entry point at %p\n", (void *)ep);

                /* Validate signature */
                if (memcmp(ep->signature, "_SM3_", 5) != 0) {
                    printf("  Invalid signature, skipping\n");
                    continue;
                }

                /* Validate checksum */
                if (smbios_checksum(ep, ep->length) != 0) {
                    printf("  Invalid checksum, skipping\n");
                    continue;
                }

                printf("  Version: %u.%u, structure table at %lx, max size %u\n",
                       ep->smbios_major_version, ep->smbios_minor_version,
                       (unsigned long)ep->structure_table_address,
                       ep->structure_table_max_size);

                /* Synthesize SMBIOS 2.x from 3.0 */
                result_ep = synthesize_smbios_21_from_30(
                    ep, ep->structure_table_address, ep->structure_table_max_size);
                break;
            }
        }
    }

    if (!result_ep) {
        printf("No usable SMBIOS table found\n");
        return -1;
    }

    priv.low_stub->boot_table.SmbiosTable = (uintptr_t)result_ep;
    priv.low_stub->boot_table.SmbiosTableLength = result_ep->structure_table_length;
    return 0;
}

EFI_STATUS efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    EFI_PHYSICAL_ADDRESS HiPmm;
    uintptr_t csm_bin_base;
    EFI_STATUS Status;
    EFI_IA32_REGISTER_SET Regs;

    gST = SystemTable;
    gBS = SystemTable->BootServices;
    gRT = SystemTable->RuntimeServices;

    csmwrap_video_early_init(&priv);

    if (priv.cb_fb.physical_address != 0) {
        flanterm_ctx = flanterm_fb_init(
            flanterm_uefi_malloc, flanterm_uefi_free,
            (void *)(uintptr_t)priv.cb_fb.physical_address, priv.cb_fb.x_resolution, priv.cb_fb.y_resolution, priv.cb_fb.bytes_per_line,
            priv.cb_fb.red_mask_size, priv.cb_fb.red_mask_pos, priv.cb_fb.green_mask_size, priv.cb_fb.green_mask_pos, priv.cb_fb.blue_mask_size, priv.cb_fb.blue_mask_pos,
            NULL,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0,
            FLANTERM_FB_ROTATE_0
        );
    }

    gBS->SetWatchdogTimer(0, 0, 0, NULL);

    printf("%s", banner);

    for (EFI_PHYSICAL_ADDRESS i = 0; i < 0x100000; i += EFI_PAGE_SIZE) {
        EFI_PHYSICAL_ADDRESS j = i;
        if (gBS->AllocatePages(AllocateAddress, EfiLoaderData, 1, &j) != EFI_SUCCESS) {
            if (i < 0xa0000) {
                printf("warning: Early AllocatePages() failed for address %p\n", i);
            }
        }
    }

    if (gRT->GetTime(&gTimeAtBoot, NULL) != EFI_SUCCESS) {
        printf("Failed to query current time\n");
        return -1;
    }

    EFI_GUID loaded_image_guid = EFI_LOADED_IMAGE_PROTOCOL_GUID;
    EFI_LOADED_IMAGE_PROTOCOL *loaded_image = NULL;
    if (gBS->HandleProtocol(ImageHandle, &loaded_image_guid, (void **)&loaded_image) != EFI_SUCCESS) {
        loaded_image = NULL;
    }

    EFI_GUID sfs_protocol_guid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *sfs_protocol = NULL;
    if (loaded_image == NULL || gBS->HandleProtocol(loaded_image->DeviceHandle, &sfs_protocol_guid, (void **)&sfs_protocol) != EFI_SUCCESS) {
        sfs_protocol = NULL;
    }

    EFI_FILE_PROTOCOL *sfs_dir = NULL;
    if (sfs_protocol == NULL || sfs_protocol->OpenVolume(sfs_protocol, &sfs_dir) != EFI_SUCCESS) {
        sfs_dir = NULL;
    }

    EFI_FILE_PROTOCOL *vgabios_file_handle = NULL;
    if (sfs_dir != NULL) {
        if (sfs_dir->Open(sfs_dir, &vgabios_file_handle, L"\\EFI\\CSMWrap\\vgabios.bin", EFI_FILE_MODE_READ, 0) == EFI_SUCCESS) {
            UINTN max_size = 256 * 1024;
            if (gBS->AllocatePool(EfiLoaderData, max_size, &vbios_loc) != EFI_SUCCESS) {
                vbios_loc = NULL;
            } else {
                if (vgabios_file_handle->Read(vgabios_file_handle, &max_size, vbios_loc) == EFI_SUCCESS) {
                    printf("Found and loaded '\\EFI\\CSMWrap\\vgabios.bin' file. Using it as our VBIOS!\n");
                    vbios_size = max_size;
                } else {
                    gBS->FreePool(vbios_loc);
                    vbios_loc = NULL;
                }
            }
            vgabios_file_handle->Close(vgabios_file_handle);
        }
        sfs_dir->Close(sfs_dir);
    }

    if (unlock_bios_region()) {
        printf("Unable to unlock BIOS region\n");
        return -1;
    }
    printf("Unlock!\n");

    apply_intel_platform_workarounds();

    csm_bin_base = (uintptr_t)BIOSROM_END - sizeof(Csm16_bin);
    priv.csm_bin_base = csm_bin_base;
    printf("csm_bin_base: 0x%lx\n", csm_bin_base);
    if (csm_bin_base < VGABIOS_END) {
        printf("Illegal csm_bin size \n");
        return -1;
    }

    priv.csm_efi_table = find_table(EFI_COMPATIBILITY16_TABLE_SIGNATURE, Csm16_bin, sizeof(Csm16_bin));
    if (priv.csm_efi_table == NULL) {
        printf("EFI_COMPATIBILITY16_TABLE not found\n");
        return -1;
    }

    /* Initialize ACPI first (needed for MADT parsing in bios_proxy_init) */
    acpi_init(&priv);

    /* Calculate RSDP copy location for MADT patching */
    void *rsdp_copy = priv.csm_bin + (priv.csm_efi_table->AcpiRsdPtrPointer - priv.csm_bin_base);

    /* Initialize BIOS proxy (find mailbox and helper entry in CSM binary) */
    if (bios_proxy_init(Csm16_bin, sizeof(Csm16_bin), rsdp_copy) != 0) {
        printf("FATAL: BIOS proxy initialization failed\n");
        for (;;) { asm volatile ("hlt"); }
    }
    pci_early_initialize();

    Status = csmwrap_video_init(&priv);

    HiPmm = 0xffffffff;
    if (gBS->AllocatePages(AllocateMaxAddress, EfiRuntimeServicesData, HIPMM_SIZE / EFI_PAGE_SIZE, &HiPmm) != EFI_SUCCESS) {
        printf("Unable to alloc HiPmm!!!\n");
        return -1;
    }

    priv.low_stub = (struct low_stub *)LOW_STUB_BASE;
    memset((void*)LOW_STUB_BASE, 0, CONVEN_END - LOW_STUB_BASE);

    set_smbios_table();
    priv.low_stub->boot_table.AcpiTable = priv.csm_efi_table->AcpiRsdPtrPointer;

    uintptr_t pmm_base = LegacyBiosInitializeThunkAndTable(LOW_STUB_BASE, sizeof(struct low_stub));

    printf("Init Thunk pmm: %lx\n", (uintptr_t)pmm_base);

    priv.low_stub->init_table.BiosLessThan1MB = 0; // SeaBIOS does not actually use this field.
    priv.low_stub->init_table.ThunkStart = (uint32_t)(uintptr_t)priv.low_stub;
    priv.low_stub->init_table.ThunkSizeInBytes = sizeof(struct low_stub);
    priv.low_stub->init_table.LowPmmMemory = (uint32_t)pmm_base;
    priv.low_stub->init_table.LowPmmMemorySizeInBytes = (uint32_t)CONVEN_END - (uint32_t)pmm_base;
    priv.low_stub->init_table.HiPmmMemorySizeInBytes = HIPMM_SIZE;
    priv.low_stub->init_table.HiPmmMemory = HiPmm;

    priv.low_stub->vga_oprom_table.OpromSegment = EFI_SEGMENT(VGABIOS_START);
    priv.low_stub->vga_oprom_table.PciBus = priv.vga_pci_bus;
    priv.low_stub->vga_oprom_table.PciDeviceFunction = priv.vga_pci_devfn;

    /* Build BBS table with boot device prioritized */
    build_bbs_table(&priv, ImageHandle);

    /* Build MP table from ACPI MADT (excludes helper core) */
    mptable_init(&priv);

    printf("CALL16 %x:%x\n", priv.csm_efi_table->Compatibility16CallSegment,
            priv.csm_efi_table->Compatibility16CallOffset);

    /* WARNING: No EFI Video afterwards */
    csmwrap_video_prepare_exitbs(&priv);

    /* WARNING: No EFI runtime service afterwards */
    UINTN efi_mmap_size = 0, efi_desc_size = 0, efi_mmap_key = 0;
    UINT32 efi_desc_ver = 0;
    EFI_MEMORY_DESCRIPTOR *efi_mmap;
    EFI_MEMORY_DESCRIPTOR tmp_mmap[1];
    efi_mmap_size = sizeof(tmp_mmap);
    gBS->GetMemoryMap(&efi_mmap_size, tmp_mmap, &efi_mmap_key, &efi_desc_size, &efi_desc_ver);
    efi_mmap_size += 4096;
    Status = gBS->AllocatePool(EfiLoaderData, efi_mmap_size, (void **)&efi_mmap);
    if (Status != EFI_SUCCESS) {
        printf("AllocatePool() for EFI memory map failed!");
        return -1;
    }
    Status = gBS->GetMemoryMap(&efi_mmap_size, efi_mmap, &efi_mmap_key, &efi_desc_size, &efi_desc_ver);
    if (Status != EFI_SUCCESS) {
        printf("GetMemoryMap() failed!");
        return -1;
    }

    // It may take N amounts of ExitBootServices() calls to complete...
    // Cap at 128.
    for (size_t i = 0; i < 128; i++) {
        Status = gBS->ExitBootServices(ImageHandle, efi_mmap_key);
        if (Status == EFI_SUCCESS) {
            break;
        }
    }
    if (Status != EFI_SUCCESS) {
        printf("Failed to exit boot services!");
        return -1;
    }

    /* Disable external interrupts */
    asm volatile ("cli");

    /* Disable IOMMUs before PCI relocation and CSM init */
    iommu_disable();

    /* Prepare APIC for legacy BIOS operation (disable or configure for ExtINT) */
    apic_prepare_for_legacy();

    pci_late_initialize();

    build_coreboot_table(&priv);

    build_e820_map(&priv, efi_mmap, efi_mmap_size, efi_desc_size);
    uintptr_t e820_low = (uintptr_t)&priv.low_stub->e820_map;
    priv.csm_efi_table->E820Pointer = e820_low;
    priv.csm_efi_table->E820Length = sizeof(EFI_E820_ENTRY64) * priv.low_stub->e820_entries;

    /* Disable 8259 PIC */
    outb(0x21, 0xff);
    outb(0xa1, 0xff);
    outb(0x43, 0x36);
    /* Program PIT to default */
    outb(0x40, 0x00);
    outb(0x40, 0x00);

    flanterm_ctx = NULL;

    /* Copy ROM to location, as late as possible */
    memcpy((void*)csm_bin_base, Csm16_bin, sizeof(Csm16_bin));
    memcpy((void*)VGABIOS_START, vbios_loc, vbios_size);

    /*
     * Start the BIOS proxy helper core now that CSM is in its final location.
     * The helper core will handle BIOS calls when the main core is in V86 mode.
     */
    if (bios_proxy_start_helper(csm_bin_base) != 0) {
        printf("FATAL: Failed to start BIOS proxy helper core\n");
        for (;;) { asm volatile("hlt"); }
    }

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16InitializeYourself;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->init_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->init_table);

    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16DispatchOprom;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->vga_oprom_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->vga_oprom_table);
    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16UpdateBbs;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->boot_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->boot_table);
    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16PrepareToBoot;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->boot_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->boot_table);

    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16Boot;
    // No arguments?

    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    return 0;
}
