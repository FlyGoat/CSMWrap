#include <efi.h>
#include <video.h>
#include <csmwrap.h>
#include <config.h>
#include <io.h>

// Generated by: xxd -i vgabios.bin >> vgabios.h
#include <bins/vgabios.h>

void *vbios_loc = NULL;
uintptr_t vbios_size;

/* Forward declaration */
static bool is_amd_rdna_or_newer(uint16_t vendor_id, uint16_t device_id);

/*
 * Calculate bits per pixel from linear pixel masks.
 * Ported from Limine.
 */
static uint16_t linear_masks_to_bpp(uint32_t red_mask, uint32_t green_mask,
                                    uint32_t blue_mask, uint32_t alpha_mask)
{
    uint32_t compound_mask = red_mask | green_mask | blue_mask | alpha_mask;
    uint16_t ret = 32;
    while ((compound_mask & (1 << 31)) == 0) {
        ret--;
        compound_mask <<= 1;
    }
    return ret;
}

/*
 * Find a GOP with a valid framebuffer and set its mode.
 * This is needed for Flanterm and SeaVGABIOS framebuffer access.
 */
static EFI_STATUS FindGop(struct csmwrap_priv *priv)
{
    EFI_STATUS Status;
    EFI_HANDLE *HandleBuffer;
    UINTN HandleCount;
    EFI_GUID gopGuid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
    EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop;

    Status = gBS->LocateHandleBuffer(
                    ByProtocol,
                    &gopGuid,
                    NULL,
                    &HandleCount,
                    &HandleBuffer
                    );
    if (EFI_ERROR(Status)) {
        printf("Failed to locate GOP handles: %d\n", Status);
        return Status;
    }

    // Iterate through each GOP handle, find one with valid FrameBufferBase
    for (UINTN i = 0; i < HandleCount; i++) {
        Status = gBS->HandleProtocol(
                        HandleBuffer[i],
                        &gopGuid,
                        (VOID**)&Gop
                        );
        if (EFI_ERROR(Status)) {
            continue;
        }

        // Initialize GOP if not started
        UINTN currentMode = Gop->Mode == NULL ? 0 : Gop->Mode->Mode;
        EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *modeInfo;
        UINTN modeInfoSize;

        Status = Gop->QueryMode(Gop, currentMode, &modeInfoSize, &modeInfo);
        if (Status == EFI_NOT_STARTED) {
            Status = Gop->SetMode(Gop, 0);
            if (EFI_ERROR(Status)) {
                continue;
            }
        }

        // Try all modes to find one with valid FrameBufferBase
        UINTN maxMode = Gop->Mode->MaxMode;
        bool found = false;
        for (UINTN mode = 0; mode < maxMode; mode++) {
            Status = Gop->SetMode(Gop, mode);
            if (EFI_ERROR(Status)) {
                continue;
            }

            if (Gop->Mode->FrameBufferBase == 0) {
                continue;
            }

            EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *mi = Gop->Mode->Info;

            /* Skip PixelBltOnly and unknown pixel formats */
            if (mi->PixelFormat >= PixelBltOnly) {
                continue;
            }

            /* Reject PixelBitMask modes with all-zero masks */
            if (mi->PixelFormat == PixelBitMask
             && (mi->PixelInformation.RedMask
               | mi->PixelInformation.GreenMask
               | mi->PixelInformation.BlueMask
               | mi->PixelInformation.ReservedMask) == 0) {
                continue;
            }

            /* Validate pitch: PixelsPerScanLine must be >= HorizontalResolution */
            if (mi->PixelsPerScanLine < mi->HorizontalResolution) {
                continue;
            }

            found = true;
            break;
        }

        if (!found) {
            continue;
        }

        priv->gop = Gop;
        priv->gop_handle = HandleBuffer[i];
        break;
    }

    gBS->FreePool(HandleBuffer);

    if (priv->gop == NULL) {
        printf("No GOP with valid framebuffer found\n");
        return EFI_NOT_FOUND;
    }

    return EFI_SUCCESS;
}

/*
 * Populate priv VGA PCI fields from a PCI I/O protocol handle.
 */
static void PopulateVgaPciInfo(struct csmwrap_priv *priv, EFI_PCI_IO_PROTOCOL *PciIo)
{
    UINT16 VendorId, DeviceId;
    UINTN Seg, Bus, Device, Function;

    priv->vga_pci_io = PciIo;

    PciIo->GetLocation(PciIo, &Seg, &Bus, &Device, &Function);

    priv->vga_pci_bus = (UINT8)Bus;
    priv->vga_pci_devfn = (UINT8)(Device << 3 | Function);

    PciIo->Pci.Read(PciIo, EfiPciIoWidthUint16, 0, 1, &VendorId);
    PciIo->Pci.Read(PciIo, EfiPciIoWidthUint16, 2, 1, &DeviceId);

    priv->vga_vendor_id = VendorId;
    priv->vga_device_id = DeviceId;

    printf("VGA PCI: %04x:%02x:%02x.%x %04x:%04x\n",
                Seg, (UINT8)Bus, (UINT8)Device, (UINT8)Function,
                VendorId, DeviceId);
}

/*
 * Find a PCI device by bus/device/function and return its PCI I/O protocol.
 */
static EFI_STATUS FindPciDevice(uint8_t bus, uint8_t device, uint8_t function,
                                 EFI_PCI_IO_PROTOCOL **OutPciIo)
{
    EFI_STATUS Status;
    EFI_HANDLE *HandleBuffer;
    UINTN HandleCount;
    EFI_GUID PciIoGuid = EFI_PCI_IO_PROTOCOL_GUID;

    Status = gBS->LocateHandleBuffer(ByProtocol, &PciIoGuid, NULL,
                                      &HandleCount, &HandleBuffer);
    if (EFI_ERROR(Status))
        return Status;

    for (UINTN i = 0; i < HandleCount; i++) {
        EFI_PCI_IO_PROTOCOL *PciIo;
        Status = gBS->HandleProtocol(HandleBuffer[i], &PciIoGuid, (VOID **)&PciIo);
        if (EFI_ERROR(Status))
            continue;

        UINTN Seg, Bus, Device, Function;
        PciIo->GetLocation(PciIo, &Seg, &Bus, &Device, &Function);

        if ((uint8_t)Bus == bus &&
            (uint8_t)Device == device &&
            (uint8_t)Function == function) {
            *OutPciIo = PciIo;
            gBS->FreePool(HandleBuffer);
            return EFI_SUCCESS;
        }
    }

    gBS->FreePool(HandleBuffer);
    return EFI_NOT_FOUND;
}

/*
 * Find PCI device info for VGA output.
 *
 * If a specific VGA device is configured, locate it by PCI address.
 * Otherwise, derive it from the GOP handle's device path.
 *
 * This is needed for OpROM loading, VGA arbitration, and legacy handoff.
 */
static EFI_STATUS FindVgaPciInfo(struct csmwrap_priv *priv)
{
    EFI_STATUS Status;
    EFI_PCI_IO_PROTOCOL *PciIo;

    /* If user specified a VGA device, find it directly by PCI address */
    if (gConfig.vga_specified) {
        Status = FindPciDevice(gConfig.vga_bus, gConfig.vga_device,
                                gConfig.vga_function, &PciIo);
        if (EFI_ERROR(Status)) {
            printf("VGA: configured device %02x:%02x.%x not found\n",
                   gConfig.vga_bus, gConfig.vga_device, gConfig.vga_function);
            return Status;
        }

        PopulateVgaPciInfo(priv, PciIo);
        return EFI_SUCCESS;
    }

    /* Default: derive from GOP handle's device path */
    EFI_GUID DevicePathGuid = EFI_DEVICE_PATH_PROTOCOL_GUID;
    EFI_GUID PciIoGuid = EFI_PCI_IO_PROTOCOL_GUID;
    EFI_DEVICE_PATH_PROTOCOL *DevicePath;
    EFI_HANDLE Handle;

    if (priv->gop_handle == NULL)
        return EFI_NOT_FOUND;

    Status = gBS->HandleProtocol(priv->gop_handle, &DevicePathGuid,
                                  (VOID **)&DevicePath);
    if (EFI_ERROR(Status))
        return Status;

    Status = gBS->LocateDevicePath(&PciIoGuid, &DevicePath, &Handle);
    if (EFI_ERROR(Status))
        return Status;

    Status = gBS->HandleProtocol(Handle, &PciIoGuid, (VOID **)&PciIo);
    if (EFI_ERROR(Status))
        return Status;

    PopulateVgaPciInfo(priv, PciIo);
    return EFI_SUCCESS;
}

static EFI_STATUS
GetPciLegacyRom (
  IN     UINT16 Csm16Revision,
  IN     UINT16 VendorId,
  IN     UINT16 DeviceId,
  IN OUT VOID   **Rom,
  IN OUT UINTN  *ImageSize,
  OUT    UINTN  *MaxRuntimeImageLength,   OPTIONAL
  OUT    UINT8  *OpRomRevision,           OPTIONAL
  OUT    VOID   **ConfigUtilityCodeHeader OPTIONAL
  )
{
  BOOLEAN                 Match;
  UINT16                  *DeviceIdList;
  EFI_PCI_ROM_HEADER      RomHeader;
  PCI_3_0_DATA_STRUCTURE  *Pcir;
  VOID                    *BackupImage;
  VOID                    *BestImage;


  if (*ImageSize < sizeof (EFI_PCI_ROM_HEADER)) {
    return EFI_NOT_FOUND;
  }

  BestImage     = NULL;
  BackupImage   = NULL;
  RomHeader.Raw = *Rom;
  while (RomHeader.Generic->Signature == PCI_EXPANSION_ROM_HEADER_SIGNATURE) {
    if (RomHeader.Generic->PcirOffset == 0 ||
        (RomHeader.Generic->PcirOffset & 3) !=0 ||
        *ImageSize < RomHeader.Raw - (UINT8 *) *Rom + RomHeader.Generic->PcirOffset + sizeof (PCI_DATA_STRUCTURE)) {
      break;
    }

    Pcir = (PCI_3_0_DATA_STRUCTURE *) (RomHeader.Raw + RomHeader.Generic->PcirOffset);
    //
    // Check signature in the PCI Data Structure.
    //
    if (Pcir->Signature != PCI_DATA_STRUCTURE_SIGNATURE) {
      break;
    }

    if (((UINTN)RomHeader.Raw - (UINTN)*Rom) + Pcir->ImageLength * 512 > *ImageSize) {
      break;
    }

    if (Pcir->CodeType == PCI_CODE_TYPE_PCAT_IMAGE) {
      Match = FALSE;
      if (Pcir->VendorId == VendorId) {
        if (Pcir->DeviceId == DeviceId) {
          Match = TRUE;
        } else if ((Pcir->Revision >= 3) && (Pcir->DeviceListOffset != 0)) {
          DeviceIdList = (UINT16 *)(((UINT8 *) Pcir) + Pcir->DeviceListOffset);
          //
          // Checking the device list
          //
          while (*DeviceIdList != 0) {
            if (*DeviceIdList == DeviceId) {
              Match = TRUE;
              break;
            }
            DeviceIdList ++;
          }
        }
      }

      if (Match) {
        if (Csm16Revision >= 0x0300) {
          //
          // Case 1: CSM16 3.0
          //
          if (Pcir->Revision >= 3) {
            //
            // case 1.1: meets OpRom 3.0
            //           Perfect!!!
            //
            BestImage  = RomHeader.Raw;
            break;
          } else {
            //
            // case 1.2: meets OpRom 2.x
            //           Store it and try to find the OpRom 3.0
            //
            BackupImage = RomHeader.Raw;
          }
        } else {
          //
          // Case 2: CSM16 2.x
          //
          if (Pcir->Revision >= 3) {
            //
            // case 2.1: meets OpRom 3.0
            //           Store it and try to find the OpRom 2.x
            //
            BackupImage = RomHeader.Raw;
          } else {
            //
            // case 2.2: meets OpRom 2.x
            //           Perfect!!!
            //
            BestImage   = RomHeader.Raw;
            break;
          }
        }
      } else {
        DEBUG ((DEBUG_ERROR, "GetPciLegacyRom - OpRom not match (%04x-%04x)\n", (UINTN)VendorId, (UINTN)DeviceId));
      }
    }

    if ((Pcir->Indicator & 0x80) == 0x80) {
      break;
    } else {
      RomHeader.Raw += 512 * Pcir->ImageLength;
    }
  }

  if (BestImage == NULL) {
    if (BackupImage == NULL) {
      return EFI_NOT_FOUND;
    }
    //
    // The versions of CSM16 and OpRom don't match exactly
    //
    BestImage = BackupImage;
  }
  RomHeader.Raw = BestImage;
  Pcir = (PCI_3_0_DATA_STRUCTURE *) (RomHeader.Raw + RomHeader.Generic->PcirOffset);
  *Rom       = BestImage;
  *ImageSize = Pcir->ImageLength * 512;

  if (MaxRuntimeImageLength != NULL) {
    if (Pcir->Revision < 3) {
      *MaxRuntimeImageLength = 0;
    } else {
      *MaxRuntimeImageLength = Pcir->MaxRuntimeImageLength * 512;
    }
  }

  if (OpRomRevision != NULL) {
    //
    // Optional return PCI Data Structure revision
    //
    if (Pcir->Length >= 0x1C) {
      *OpRomRevision = Pcir->Revision;
    } else {
      *OpRomRevision = 0;
    }
  }

  if (ConfigUtilityCodeHeader != NULL) {
    //
    // Optional return ConfigUtilityCodeHeaderOffset supported by the PC-AT ROM
    //
    if ((Pcir->Revision < 3) || (Pcir->ConfigUtilityCodeHeaderOffset == 0)) {
      *ConfigUtilityCodeHeader = NULL;
    } else {
      *ConfigUtilityCodeHeader = RomHeader.Raw + Pcir->ConfigUtilityCodeHeaderOffset;
    }
  }

  return EFI_SUCCESS;
}


static EFI_STATUS csmwrap_pci_vgaarb(struct csmwrap_priv *priv)
{
    EFI_STATUS Status;
    EFI_PCI_IO_PROTOCOL *PciIo = priv->vga_pci_io;
    UINT64 Attributes = 0;
    UINT64 Supported = 0;
    BOOLEAN unsupported = FALSE;

    if (!PciIo) {
        return -1;
    }

    Status = PciIo->Attributes(PciIo, EfiPciIoAttributeOperationSupported,
                               0, &Supported);

    if (EFI_ERROR(Status)) {
        printf("%s: Failed to get supported attributes: %d\n", __func__, Status);
        return Status;
    }

    Attributes = Supported & (EFI_PCI_IO_ATTRIBUTE_VGA_IO | EFI_PCI_IO_ATTRIBUTE_VGA_IO_16);

    if (Attributes == 0) {
        printf("%s: No VGA IO attributes support\n", __func__);
        unsupported = TRUE;
    } else if (Attributes == (EFI_PCI_IO_ATTRIBUTE_VGA_IO | EFI_PCI_IO_ATTRIBUTE_VGA_IO_16)) {
        Attributes = EFI_PCI_IO_ATTRIBUTE_VGA_IO; // We want to use regular VGA IO
    }

    if (Supported & EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY) {
        Attributes |= EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY;
    } else {
        printf("%s: No VGA memory attributes support\n", __func__);
        unsupported = TRUE;
    }

    if (unsupported) {
        printf("%s: Unable to select attribute\n", __func__);
        return -1;
    }

    Status = PciIo->Attributes(PciIo, EfiPciIoAttributeOperationEnable,
                               Attributes, NULL);
    if (EFI_ERROR(Status)) {
        printf("%s: Failed to set attributes: %d\n", __func__, Status);
        return Status;
    }

    printf("%s: Success! Attributes: %llx\n", __func__, Attributes);

    return 0;
}

static EFI_STATUS csmwrap_video_oprom_init(struct csmwrap_priv *priv)
{
    EFI_STATUS Status;
    PCI_TYPE00 PciConfigHeader;
    EFI_PCI_IO_PROTOCOL *PciIo;
    UINTN  LocalRomSize;
    VOID  *LocalRomImage;

    /* Find PCI device info - required for OpROM */
    FindVgaPciInfo(priv);

    PciIo = priv->vga_pci_io;
    if (!PciIo || !PciIo->RomImage || !PciIo->RomSize) {
        return EFI_UNSUPPORTED;
    }

    /*
     * AMD RDNA+ iGPUs have broken legacy OpROMs that don't work properly
     * with SeaBIOS. Force SeaVGABIOS for these GPUs.
     */
    if (is_amd_rdna_or_newer(priv->vga_vendor_id, priv->vga_device_id)) {
        printf("AMD RDNA+ GPU detected (device %04x), skipping OpROM\n",
               priv->vga_device_id);
        return EFI_UNSUPPORTED;
    }

    /* Enable VGA routing to this device for legacy OpROM execution */
    csmwrap_pci_vgaarb(priv);

    LocalRomSize  = (UINTN) PciIo->RomSize;
    LocalRomImage = PciIo->RomImage;

    PciIo->Pci.Read (
            PciIo,
            EfiPciIoWidthUint32,
            0,
            sizeof (PciConfigHeader) / sizeof (UINT32),
            &PciConfigHeader
            );

    Status = GetPciLegacyRom (
             0x0300, // ???
             PciConfigHeader.Hdr.VendorId,
             PciConfigHeader.Hdr.DeviceId,
             &LocalRomImage,
             &LocalRomSize,
             NULL /* RuntimeImageLength */,
             NULL /* OpromRevision */,
             NULL /* &LocalConfigUtilityCodeHeader */
             );

    if (EFI_ERROR(Status)) {
        DEBUG((DEBUG_ERROR, "GetPciLegacyRom failed: %r\n", Status));
        return Status;
    }

    vbios_loc = LocalRomImage;
    vbios_size = LocalRomSize;

    priv->video_type = CSMWRAP_VIDEO_OPROM;

    printf("Video Initialisation Succeed with OpROM\n");

    return 0;
}

static EFI_STATUS csmwrap_video_seavgabios_init(struct csmwrap_priv *priv)
{
    struct cb_framebuffer *cb_fb = &priv->cb_fb;
    unsigned long fb_addr = 0;
    EFI_STATUS status;
    EFI_GRAPHICS_OUTPUT_PROTOCOL *gop = priv->gop;
    EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info = NULL;
    UINTN isiz = sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION), currentMode;

    if (!gop) {
        return EFI_UNSUPPORTED;
    }

    /* Mode already set by FindGopPciDevice, just query info */
    currentMode = gop->Mode->Mode;
    status = gop->QueryMode(gop, currentMode, &isiz, &info);
    if (EFI_ERROR(status)) {
        printf("unable to get current video mode\n");
        return -1;
    }

    printf("%c %3d. %4d x%4d (pitch %4d fmt %d r:%06x g:%06x b:%06x)\n",
        '*', currentMode,
        info->HorizontalResolution, info->VerticalResolution, info->PixelsPerScanLine, info->PixelFormat,
        info->PixelFormat==PixelRedGreenBlueReserved8BitPerColor?0xff:(
        info->PixelFormat==PixelBlueGreenRedReserved8BitPerColor?0xff0000:(
        info->PixelFormat==PixelBitMask?info->PixelInformation.RedMask:0)),
        info->PixelFormat==PixelRedGreenBlueReserved8BitPerColor ||
        info->PixelFormat==PixelBlueGreenRedReserved8BitPerColor?0xff00:(
        info->PixelFormat==PixelBitMask?info->PixelInformation.GreenMask:0),
        info->PixelFormat==PixelRedGreenBlueReserved8BitPerColor?0xff0000:(
        info->PixelFormat==PixelBlueGreenRedReserved8BitPerColor?0xff:(
        info->PixelFormat==PixelBitMask?info->PixelInformation.BlueMask:0)));

    fb_addr = (unsigned long)gop->Mode->FrameBufferBase;

    printf("EFI Framebuffer: %lx\n", fb_addr);

    if (!fb_addr) {
        printf("Framebuffer invalid.\n");
        return EFI_UNSUPPORTED;
    }

    cb_fb->physical_address = fb_addr;
    cb_fb->x_resolution = info->HorizontalResolution;
    cb_fb->y_resolution = info->VerticalResolution;

    switch (info->PixelFormat) {
        case PixelRedGreenBlueReserved8BitPerColor:
            cb_fb->bits_per_pixel = 32;
            cb_fb->red_mask_pos = 0;
            cb_fb->red_mask_size = 8;
            cb_fb->green_mask_pos = 8;
            cb_fb->green_mask_size = 8;
            cb_fb->blue_mask_pos = 16;
            cb_fb->blue_mask_size = 8;
            cb_fb->reserved_mask_pos = 24;
            cb_fb->reserved_mask_size = 8;
            break;
        case PixelBlueGreenRedReserved8BitPerColor:
            cb_fb->bits_per_pixel = 32;
            cb_fb->blue_mask_pos = 0;
            cb_fb->blue_mask_size = 8;
            cb_fb->green_mask_pos = 8;
            cb_fb->green_mask_size = 8;
            cb_fb->red_mask_pos = 16;
            cb_fb->red_mask_size = 8;
            cb_fb->reserved_mask_pos = 24;
            cb_fb->reserved_mask_size = 8;
            break;
        case PixelBitMask:
            /* Reject modes with all-zero pixel masks */
            if ((info->PixelInformation.RedMask
               | info->PixelInformation.GreenMask
               | info->PixelInformation.BlueMask
               | info->PixelInformation.ReservedMask) == 0) {
                printf("PixelBitMask mode with all-zero masks\n");
                return EFI_UNSUPPORTED;
            }

            /* Calculate BPP from masks instead of assuming 32 */
            cb_fb->bits_per_pixel = linear_masks_to_bpp(
                info->PixelInformation.RedMask,
                info->PixelInformation.GreenMask,
                info->PixelInformation.BlueMask,
                info->PixelInformation.ReservedMask);

            // Calculate position (find first set bit, 0 if mask is empty)
            cb_fb->red_mask_pos = info->PixelInformation.RedMask ? __builtin_ffs(info->PixelInformation.RedMask) - 1 : 0;
            cb_fb->green_mask_pos = info->PixelInformation.GreenMask ? __builtin_ffs(info->PixelInformation.GreenMask) - 1 : 0;
            cb_fb->blue_mask_pos = info->PixelInformation.BlueMask ? __builtin_ffs(info->PixelInformation.BlueMask) - 1 : 0;
            cb_fb->reserved_mask_pos = info->PixelInformation.ReservedMask ? __builtin_ffs(info->PixelInformation.ReservedMask) - 1 : 0;

            // Calculate size (count set bits)
            cb_fb->red_mask_size = __builtin_popcount(info->PixelInformation.RedMask);
            cb_fb->green_mask_size = __builtin_popcount(info->PixelInformation.GreenMask);
            cb_fb->blue_mask_size = __builtin_popcount(info->PixelInformation.BlueMask);
            cb_fb->reserved_mask_size = __builtin_popcount(info->PixelInformation.ReservedMask);
            break;
        default:
            printf("Unsupported pixel format: %d\n", info->PixelFormat);
            return EFI_UNSUPPORTED;
    }

    /*
     * Recalculate pitch from gop->Mode->Info, as some firmware (e.g. Apple
     * Macs) report incorrect PixelsPerScanLine via QueryMode.
     */
    cb_fb->bytes_per_line = gop->Mode->Info->PixelsPerScanLine * (cb_fb->bits_per_pixel / 8);

    /* Validate pitch */
    {
        uint32_t bytes_per_pixel = cb_fb->bits_per_pixel / 8;
        if (bytes_per_pixel == 0
         || cb_fb->bytes_per_line % bytes_per_pixel != 0
         || cb_fb->bytes_per_line < cb_fb->x_resolution * bytes_per_pixel) {
            printf("Invalid pitch %u (width=%u, bpp=%u)\n",
                   cb_fb->bytes_per_line, cb_fb->x_resolution, cb_fb->bits_per_pixel);
            return EFI_UNSUPPORTED;
        }
    }

    vbios_loc = vgabios_bin;
    vbios_size = sizeof(vgabios_bin);

    priv->video_type = CSMWRAP_VIDEO_SEAVGABIOS;

    printf("Video Initialisation Succeed with SeaVGABIOS GOP\n");

    return 0;

}

EFI_STATUS csmwrap_video_prepare_exitbs(struct csmwrap_priv *priv)
{
    /*
     * Unlink Controller before ExitBS, it mat disable FB so we can't
     * do that for other video types.
     */
    if (priv->video_type == CSMWRAP_VIDEO_OPROM) {
        EFI_STATUS Status;

        if (!priv->gop_handle) {
            DEBUG((DEBUG_ERROR, "No GOP handle found\n"));
            return EFI_UNSUPPORTED;
        }

        if (gBS->Hdr.Revision < EFI_1_10_BOOT_SERVICES_REVISION && !gBS->DisconnectController) {
            DEBUG((DEBUG_ERROR, "DisconnectController not supported\n"));
            return EFI_UNSUPPORTED;
        }

        Status = gBS->DisconnectController(
                        priv->gop_handle,
                        NULL,
                        NULL
                        );

        if (EFI_ERROR(Status)) {
            DEBUG((DEBUG_ERROR, "DisconnectController failed: %d\n", Status));
            return Status;
        }
    }

    return EFI_SUCCESS;
}

/*
 * Check if the GPU is AMD RDNA or newer architecture.
 *
 * AMD RDNA+ iGPUs have broken/non-functional legacy VGA BIOS (OpROM),
 * so we need to force SeaVGABIOS even if the GPU advertises an OpROM.
 *
 * Strategy: Instead of listing all RDNA+ device IDs (which requires constant
 * updates), we whitelist known-good pre-RDNA (Vega-based) APUs and assume
 * any other AMD iGPU in the typical APU device ID ranges is RDNA+.
 *
 * Device IDs sourced from Linux amdgpu driver and Folding@home GPU database.
 */
#define AMD_VENDOR_ID 0x1002

static bool is_amd_vega_apu(uint16_t device_id)
{
    /*
     * Known Vega-based APUs with working legacy OpROM:
     * - Raven Ridge (Ryzen 2000 APU)
     * - Picasso (Ryzen 3000 APU)
     * - Renoir (Ryzen 4000 APU)
     * - Lucienne (Ryzen 5000 APU, Zen 2 refresh)
     * - Cezanne (Ryzen 5000 APU, Zen 3)
     * - Barcelo (Ryzen 5000 APU refresh)
     */
    switch (device_id) {
    case 0x15D8:  /* Picasso */
    case 0x15DD:  /* Raven Ridge */
    case 0x15E7:  /* Barcelo */
    case 0x1636:  /* Renoir */
    case 0x1638:  /* Renoir/Cezanne */
    case 0x164C:  /* Lucienne */
        return true;
    default:
        return false;
    }
}

static bool is_amd_rdna_or_newer(uint16_t vendor_id, uint16_t device_id)
{
    if (vendor_id != AMD_VENDOR_ID)
        return false;

    /*
     * AMD RDNA 1/2/3/4 discrete GPUs (Navi series):
     * - 0x73xx: Navi 10/12/14 (RDNA 1), Navi 21/22/23 (RDNA 2)
     * - 0x74xx: Navi 24 (RDNA 2), Navi 31/32/33 (RDNA 3)
     * - 0x75xx: Navi 48/44 (RDNA 4)
     */
    if ((device_id & 0xFF00) == 0x7300 ||
        (device_id & 0xFF00) == 0x7400 ||
        (device_id & 0xFF00) == 0x7500)
        return true;

    /*
     * AMD APU/iGPU detection:
     * Device IDs in ranges 0x14xx, 0x15xx, 0x16xx, 0x19xx are typically iGPUs.
     * If it's not a known Vega APU, assume it's RDNA+ with broken OpROM.
     */
    if ((device_id & 0xFF00) == 0x1400 ||
        (device_id & 0xFF00) == 0x1500 ||
        (device_id & 0xFF00) == 0x1600 ||
        (device_id & 0xFF00) == 0x1900) {
        /* Check if it's a known-good Vega APU */
        if (is_amd_vega_apu(device_id))
            return false;
        /* Unknown APU in these ranges - assume RDNA+ */
        return true;
    }

    return false;
}

void csmwrap_video_early_init(struct csmwrap_priv *priv) {
    if (FindGop(priv) != EFI_SUCCESS) {
        priv->cb_fb.physical_address = 0;
        return;
    }

    if (csmwrap_video_seavgabios_init(priv) != EFI_SUCCESS) {
        priv->cb_fb.physical_address = 0;
        return;
    }

    /* Clear vbios_loc so csmwrap_video_init() doesn't skip OpROM init */
    vbios_loc = NULL;
}

/*
 * If a specific VGA device is configured, find its GOP handle and switch
 * priv->gop_handle so that DisconnectController targets the correct device
 * during exit-boot-services preparation.
 */
static void FindVgaGop(struct csmwrap_priv *priv)
{
    EFI_HANDLE *HandleBuffer;
    UINTN HandleCount;
    EFI_GUID gopGuid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
    EFI_GUID DevicePathGuid = EFI_DEVICE_PATH_PROTOCOL_GUID;
    EFI_GUID PciIoGuid = EFI_PCI_IO_PROTOCOL_GUID;

    if (gBS->LocateHandleBuffer(ByProtocol, &gopGuid, NULL,
                                 &HandleCount, &HandleBuffer))
        return;

    for (UINTN i = 0; i < HandleCount; i++) {
        EFI_DEVICE_PATH_PROTOCOL *DevicePath;
        if (gBS->HandleProtocol(HandleBuffer[i], &DevicePathGuid,
                                 (VOID **)&DevicePath))
            continue;

        EFI_HANDLE PciHandle;
        if (gBS->LocateDevicePath(&PciIoGuid, &DevicePath, &PciHandle))
            continue;

        EFI_PCI_IO_PROTOCOL *PciIo;
        if (gBS->HandleProtocol(PciHandle, &PciIoGuid, (VOID **)&PciIo))
            continue;

        UINTN Seg, Bus, Device, Function;
        PciIo->GetLocation(PciIo, &Seg, &Bus, &Device, &Function);

        if ((uint8_t)Bus != gConfig.vga_bus ||
            (uint8_t)Device != gConfig.vga_device ||
            (uint8_t)Function != gConfig.vga_function)
            continue;

        EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop;
        if (gBS->HandleProtocol(HandleBuffer[i], &gopGuid, (VOID **)&Gop))
            continue;

        priv->gop = Gop;
        priv->gop_handle = HandleBuffer[i];
        printf("VGA: switched GOP to configured device %02x:%02x.%x\n",
               gConfig.vga_bus, gConfig.vga_device, gConfig.vga_function);
        break;
    }

    gBS->FreePool(HandleBuffer);
}

EFI_STATUS csmwrap_video_init(struct csmwrap_priv *priv)
{
    EFI_STATUS status;

    /* Find GOP if not already found by early init */
    if (!priv->gop) {
        status = FindGop(priv);
        if (EFI_ERROR(status)) {
            printf("Unable to get GOP service\n");
            return -1;
        }
    }

    if (vbios_loc != NULL) {
        /*
         * User-provided VBIOS: still need PCI info and VGA arbitration
         * so the VBIOS is dispatched to the right device.
         */
        FindVgaPciInfo(priv);
        csmwrap_pci_vgaarb(priv);
        if (gConfig.vga_specified)
            FindVgaGop(priv);
        priv->video_type = CSMWRAP_VIDEO_OPROM;
        return 0;
    }

    /* Try OpROM first (will fail if no PCI info or AMD RDNA+) */
    status = csmwrap_video_oprom_init(priv);
    if (status == EFI_SUCCESS) {
        /*
         * Switch gop_handle to the VGA device so DisconnectController
         * targets the right device during exit-boot-services preparation.
         */
        if (gConfig.vga_specified) {
            FindVgaGop(priv);
        }
        return 0;
    }

    if (gConfig.vga_specified) {
        printf("VGA: configured device %02x:%02x.%x has no usable OpROM, ignoring\n",
               gConfig.vga_bus, gConfig.vga_device, gConfig.vga_function);
    }

    status = csmwrap_video_seavgabios_init(priv);
    if (status == EFI_SUCCESS) {
        return 0;
    }

    panic("No video initialization method available\n");
}

